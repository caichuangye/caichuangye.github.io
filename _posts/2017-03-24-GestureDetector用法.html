<!DOCTYPE html><html><head><title>GestureDetector用法</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style>
.note-content  {font-family: "Helvetica Neue", Arial, "Hiragino Sans GB", STHeiti, "Microsoft YaHei", "WenQuanYi Micro Hei", SimSun, Song, sans-serif;}

</style></head><body><div id='preview-contents' class='note-content'>
                        
                    



<h3 id="gesturedetector用法">GestureDetector用法</h3>

<div><div class="toc"><div class="toc">
<ul>
<li><ul>
<li><ul>
<li><a href="#gesturedetector用法">GestureDetector用法</a><ul>
<li><a href="#一-基本用法">一. 基本用法</a><ul>
<li><a href="#1-创建gesturedetector对象">1. 创建GestureDetector对象</a></li>
<li><a href="#2-调用gesturedetector的ontouchevent函数">2. 调用GestureDetector的onTouchEvent函数</a></li>
</ul>
</li>
<li><a href="#二-监听回调介绍">二. 监听回调介绍</a><ul>
<li><a href="#1-ongesturelistener">1. OnGestureListener</a></li>
<li><a href="#2-ondoubletaplistener">2. OnDoubleTapListener</a></li>
<li><a href="#3-oncontextclicklistener">3. OnContextClickListener</a></li>
</ul>
</li>
<li><a href="#三-典型事件">三. 典型事件</a><ul>
<li><a href="#1-单击">1. 单击</a></li>
<li><a href="#2-双击">2. 双击</a></li>
<li><a href="#3-长按">3. 长按</a></li>
<li><a href="#4-滑动">4. 滑动</a></li>
<li><a href="#5-抛fling">5. 抛(fling)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<p></p>



<h4 id="一-基本用法">一. 基本用法</h4>



<h5 id="1-创建gesturedetector对象">1. 创建GestureDetector对象</h5>

<p>GestureDetector有三个构造函数，如下：</p>

<ol><li rel="1">public GestureDetector(Context context, OnGestureListener listener)</li>
<li rel="2">public GestureDetector(Context context, OnGestureListener listener, Handler handler)</li>
<li rel="3">public GestureDetector(Context context, OnGestureListener listener, Handler handler, <br>
        boolean unused) <br>
其中，第一个和第三个本质上调用的是第二个构造函数，第二个构造函数有3个参数，分别为： <br>
<ul>
<li>Context：用来获取ViewConfiguration对象</li>
<li>OnGestureListener ：事件回调，除了传入OnGestureListener 的实例，还可以传入SimpleOnGestureListener的实例</li>
<li>Handler：运行事件回调所在的线程</li></ul></li>
</ol>



<h5 id="2-调用gesturedetector的ontouchevent函数">2. 调用GestureDetector的onTouchEvent函数</h5>



<pre class="prettyprint with-line-number hljs-dark"><code class="language-java hljs"><span class="hljs-comment line-number">1.</span>mButton.setOnTouchListener(<span class="hljs-keyword">new</span> View.OnTouchListener() {<br><span class="hljs-comment line-number">2.</span>      <span class="hljs-annotation">@Override</span><br><span class="hljs-comment line-number">3.</span>       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTouch</span><span class="hljs-params">(View v, MotionEvent event)</span> </span>{<br><span class="hljs-comment line-number">4.</span>            mGestureDetector.onTouchEvent(event);<br><span class="hljs-comment line-number">5.</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br><span class="hljs-comment line-number">6.</span>       }<br><span class="hljs-comment line-number">7.</span>});<br></code></pre>



<h4 id="二-监听回调介绍">二. 监听回调介绍</h4>



<h5 id="1-ongesturelistener">1. OnGestureListener</h5>

<p></p><ul><li><code>boolean onDown(MotionEvent e)</code> <br></li></ul><p></p>

<blockquote>
  当MotionEvent的Down事件发生时，触发这个回调。只要用户触碰到屏幕，首先触发的就是该回调。
  
  </blockquote>


<hr>

<p></p><ul><li><code>void onShowPress(MotionEvent e)</code> <br></li></ul><p></p>

<blockquote>
   当MotionEvent的Down事件发生但Move和Up还没发生时会触发该回调。这个回调一般用于为用户提供视觉反馈，好让 <br>
    用户知道他们的行为已经被识别了，比如高亮一个元素。单击、双击时不会触发，长按、移动时触发，<code>即Down事件持续100ms后，才会触发该回调。</code>
  
  </blockquote>


<hr>

<p></p><ul><li><code>boolean onSingleTapUp(MotionEvent e)</code> <br></li></ul><p></p>

<blockquote>
  当Up事件发生时，触发这个回调，触发该事件表明一个Click事件已经发生。
  
  </blockquote>


<hr>

<p></p><ul><li><code>boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)</code> <br></li></ul><p></p>

<blockquote>
  滑动事件发生时将触发该回调。 <br>
  @param e1： 开始滑动时的第一个Down事件 <br>
  @param e2： 触发当前事件的MotionEvent事件 <br>
  @param distanceX：  最后一次调用onScroll时在X轴上划过的距离，<code>不是e1和e2之间的距离</code> <br>
  @param distanceY ： 最后一次调用onScroll时在Y轴上划过的距离，<code>不是e1和e2之间的距离</code> <br>
  @如果事件被消费，返回true，否则返回false
  
  </blockquote>


<hr>

<p></p><ul><li><code>void onLongPress(MotionEvent e)</code> <br></li></ul><p></p>

<blockquote>
  当长按事件发生时，将立即触发这个回调。<code>Down事件发生后500ms，并且在这段时间内没有其他的事件，</code> <br>
  <code>则视为长按。参数e为Click的Down事件，不是Up！</code>
  
  </blockquote>


<hr>

<p></p><ul><li><code>boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)</code> <br></li></ul><p></p>

<blockquote>
  当fling动作发生时，将触发该回调 <br>
   @param e1：开始fling动作时的第一个Down事件 <br>
  @param e2 触发当前onFling事件的MotionEvent事件 <br>
  @param velocityX ：当前fling动作在X轴方向上每秒移动的像素数 <br>
  @param velocityY：当前fling动作在X轴方向上每秒移动的像素数 <br>
  @如果该事件被消费，返回true，否则返回false
  
  </blockquote>


<hr>



<h5 id="2-ondoubletaplistener">2. OnDoubleTapListener</h5>

<p></p><ul><li><code>boolean onSingleTapConfirmed(MotionEvent e)</code> <br></li></ul><p></p>

<blockquote>
  当单击事件发生时，触发该回调。当调用该回调时，监测者可以非常自信的确保接下来不会再有一个tap事件，如果两个tap事件间隔太近（小于300ms）就会变成双击事件。<code>参数e为单击事件的Down事件！</code>
  
  </blockquote>


<hr>

<p></p><ul><li><code>boolean onDoubleTap(MotionEvent e)</code> <br></li></ul><p></p>

<blockquote>
  当双击事件发生时，触发这个回调。<code>第一个Click事件的Up和第二个Click事件的Down之间的间隔小于300则视为双击事件，双击事件的触发时机为第二次Down事件！</code>
  
  </blockquote>


<hr>

<p></p><ul><li><code>boolean onDoubleTapEvent(MotionEvent e)</code> <br></li></ul><p></p>

<blockquote>
  当双击事件发生时，触发这个回调。当onDoubleTap发生后，会触发该回调，<code>从双击事件的第二次Down开始，直到双击事件结束，所有的事件都可以通过该回调监听，包括（down、move、up）。</code>
  
  </blockquote>


<hr>



<h5 id="3-oncontextclicklistener">3. OnContextClickListener</h5>

<p></p><ul><li><code>boolean onContextClick(MotionEvent e)</code> <br></li></ul><p></p>

<blockquote>
  当上下文点击事件发生时，触发这个回调
  
  </blockquote>


<hr>



<h4 id="三-典型事件">三. 典型事件</h4>



<h5 id="1-单击">1. 单击</h5>

<p>情景1：Down与UP之间的间隔小于100ms <br>
<code>onDown(down) -&gt; onSingleTapUp(up) -&gt; onSingleTapConfirmed(down)</code></p>

<p>情景2：Down与UP之间的间隔大于100ms、小于500ms <br>
<code>onDown(down) -&gt; onShowPress(down) -&gt; onSingleTapUp(up) -&gt; onSingleTapConfirmed(down)</code></p>

<p>情景3：Down与UP之间的间隔大于500ms，即长按 <br>
<code>onDown(down) -&gt; onShowPress(down) -&gt; onLongPress(down)</code></p>

<p>当Up发生时，表明一个Click事件已经发生，接下来的onSingleTapConfirmed是用来确认当前发生的是单击事件，而不是双击事件，onSingleTapConfirmed发生时其参数为Down事件，该事件是单击事件的down事件，与onDown时的事件相同。</p>



<h5 id="2-双击">2. 双击</h5>

<p><code>onDown(down) -&gt; onSingleTapUp(up) -&gt; onDoubleTap(down) -&gt; onDoubleTapEvent(down) -&gt; onDown(down)-&gt; onDoubleTapEvent(move)-&gt; onDoubleTapEvent(up)</code> <br>
如果第一个Click事件的Up和第二个Click的Down之间的间隔小于300ms，则视为双击，否则就是两次单击。 <br>
在onSingleTapUp后，下个事件是onDoubleTap，可见双击事件的通知是在第二次Down事件发生时。接下来通过onDoubleTapEvent检测从双击事件确认发生（第二次Down）到结束后的所有动作，包括down、move和up。</p>



<h5 id="3-长按">3. 长按</h5>

<p><code>onDown(down) -&gt; onShowPress(down) -&gt; onLongPress(down)</code> <br>
Down事件持续500ms并且在此期间没有其他事件，则视为长按</p>



<h5 id="4-滑动">4. 滑动</h5>

<p><code>onDown(down) -&gt; onShowPress(down) -&gt; onScroll(move) -&gt; ... -&gt; onScroll(move)</code></p>



<h5 id="5-抛fling">5. 抛(fling)</h5>

<p>情形1：Down持续事件小于100ms，然后执行move和up <br>
<code>onDown(down) -&gt; onScroll(move)-&gt; ... -&gt; onScroll(move) -&gt; onFling(up)</code></p>

<p>情形2：Down持续事件大于100ms，然后执行move和up <br>
<code>onDown(down) -&gt; onShowPress(down) -&gt;onScroll(move)-&gt; ... -&gt; onScroll(move) -&gt; onFling(up)</code></p>

<p><strong><code>总结：</code></strong> <br>
<strong><code>1. 单击事件首先由Down触发，当Down的时间持续100ms时，会触发onShowPress，当Down持续的时间500ms时，单击事件会变为长按事件。</code></strong> <br>
<strong><code>2. 第一次Click的Up事件和第二次Click的Down事件之间的间隔如果小于300ms，则视为双击，否则视为两次单击。</code></strong> <br>
<strong><code>2. 长按之后，即使快速执行第二次Click，也不会被视为双击。</code></strong></p></div></body></html>